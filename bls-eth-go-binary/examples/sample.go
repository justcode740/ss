package main

import (
	"bufio"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/360EntSecGroup-Skylar/excelize/v2"
	"github.com/herumi/bls-eth-go-binary/bls"
)

var allValidators map[int]string

func sample1() {
	fmt.Printf("sample1\n")
	var sec bls.SecretKey
	sec.SetByCSPRNG()
	msg := []byte("abc")
	pub := sec.GetPublicKey()
	fmt.Println(pub)
	sig := sec.SignByte(msg)
	fmt.Println(sig)
	fmt.Printf("verify=%v\n", sig.VerifyByte(pub, msg))
}

func sample2() {
	fmt.Printf("sample2\n")
	var sec bls.SecretKey
	sec.SetByCSPRNG()
	fmt.Printf("sec:%s\n", sec.SerializeToHexStr())
	pub := sec.GetPublicKey()
	fmt.Printf("1.pub:%s\n", pub.SerializeToHexStr())
	fmt.Printf("1.pub x=%x\n", pub)
	var P *bls.G1 = bls.CastFromPublicKey(pub)
	bls.G1Normalize(P, P)
	fmt.Printf("2.pub:%s\n", pub.SerializeToHexStr())
	fmt.Printf("2.pub x=%x\n", pub)
	fmt.Printf("P.X=%x\n", P.X.Serialize())
	fmt.Printf("P.Y=%x\n", P.Y.Serialize())
	fmt.Printf("P.Z=%x\n", P.Z.Serialize())
}

func sample3() {
	fmt.Printf("sample3\n")
	var sec bls.SecretKey
	b := make([]byte, 64)
	for i := 0; i < len(b); i++ {
		b[i] = 0xff
	}
	err := sec.SetLittleEndianMod(b)
	if err != nil {
		fmt.Printf("err")
		return
	}
	fmt.Printf("sec=%x\n", sec.Serialize())
}

func sample4() {
	fmt.Printf("sample4\n")
	var sec bls.SecretKey
	secByte, _ := hex.DecodeString("4aac41b5cb665b93e031faa751944b1f14d77cb17322403cba8df1d6e4541a4d")
	sec.Deserialize(secByte)
	fmt.Println(sec)
	msg := []byte("message to be signed.")
	fmt.Printf("sec:%x\n", sec.Serialize())
	pub := sec.GetPublicKey()
	fmt.Printf("pub:%x\n", pub.Serialize())
	sig := sec.SignByte(msg)
	fmt.Printf("sig:%x\n", sig.Serialize())
}

// this function return true if sigToVerify is aggregated signature generated by hexstring pk each independently sign the same underlying msg, otherwise return false
func aggregateVerify(msg []byte, rawPks []string, sigToVerify string) bool {
	sig := bls.Sign{}
	sig.DeserializeHexStr(sigToVerify)
	
	var pks []bls.PublicKey
	for _, rawPk := range rawPks {
		pk := bls.PublicKey{}
		pk.DeserializeHexStr(rawPk)
		pks = append(pks, pk)
	}

	return sig.FastAggregateVerify(pks, msg)
}


func verfiyAttestationByValidatorAndBlock(validator int, blockSlot int) []bool {
	block := readBlockInfo(uint(blockSlot))
	res := []bool{}
	for _, attestation := range (block.Data) {
		if contains(attestation.Validators, validator) {
			// get data root
			signing_root := getSigningRoot2(attestation.Beaconblockroot[2:], attestation.Signature[2:], uint(attestation.Slot), uint(attestation.Committeeindex), uint(attestation.SourceEpoch), uint(attestation.TargetEpoch), attestation.SourceRoot[2:], attestation.TargetRoot[2:])
			// get pubkeys
			var pks []string
			for _, idx := range attestation.Validators {
				// fmt.Println(idx, all_validators[idx], all_validators[idx]])
				
				pks = append(pks, allValidators[idx][2:])
			}
			// get sig to verify
			sig := attestation.Signature[2:]
			res = append(res, aggregateVerify(signing_root[:], pks, sig))
		}
	}
	return res
}

func checkExcel() {
	f, err := excelize.OpenFile("./data/unslashed_double_votes.xlsx")
	if err!=nil {
		fmt.Println(err)
	}
	eth2Client := newEth2Client()
	for i := 2; i < 200; i++ {
		idx := strconv.Itoa(i)
		validatorIdx, _ := f.GetCellValue("unslashed_double_votes", "B"+idx)
		validator, _ := strconv.Atoi(validatorIdx)
		blocksStr, _ := f.GetCellValue("unslashed_double_votes", "C"+idx)
		var blocks []int
		err := json.Unmarshal([]byte(blocksStr), &blocks)
		if err != nil {
			fmt.Println(err)
		}
		blocks = removeDuplicateInt(blocks)
		for _, blockSlot := range blocks {
			_, pks, sig, err := eth2Client.GetAttestationsForBlock(uint(blockSlot), validator)
			if err != nil {
				fmt.Print(err)
			}else{
				fmt.Print(strconv.FormatBool(aggregateVerify(nil, pks, sig)) + "    ")
			}
			time.Sleep(1 * time.Second)
			
		}
		fmt.Println()
	}
}

func checkDoubleVoteWithLocalData(){
	f, err := excelize.OpenFile("./data/unslashed_double_votes.xlsx")
	if err!=nil {
		fmt.Println(err)
	}

	defer f.Close()
	
	// 405
	for i := 2; i < 406; i++ {
		idx := strconv.Itoa(i)
		validatorIdx, _ := f.GetCellValue("unslashed_double_votes", "B"+idx)
		validator, _ := strconv.Atoi(validatorIdx)
		blocksStr, _ := f.GetCellValue("unslashed_double_votes", "C"+idx)
		var blocks []int
		err := json.Unmarshal([]byte(blocksStr), &blocks)
		if err != nil {
			fmt.Println(err)
		}
		blocks = removeDuplicateInt(blocks)
		// c, t, f:=0,0,0
		
		for _, blockSlot := range blocks {
			res := verfiyAttestationByValidatorAndBlock(validator, blockSlot)
			for _, r:= range res {
				fmt.Print(strconv.FormatBool(r)+"  ")
			}
		}
		fmt.Println()
	}
	
}

func checkSurroundVoteWithLocalData(){
	f, err := os.Open("./data/surround_vote")
	if err!=nil {
		fmt.Println(err)
	}

	defer f.Close()

    scanner := bufio.NewScanner(f)
    // optionally, resize scanner's capacity for lines over 64K, see next example
	first := true
    for scanner.Scan() {
		if first {
			first = false
			continue
		}
		vals := strings.Fields(scanner.Text())
		idx, _ := strconv.Atoi(vals[0])
		blockslot, _ := strconv.Atoi(vals[1])
		res := verfiyAttestationByValidatorAndBlock(idx, blockslot)
        for _, r:= range res {
			fmt.Print(strconv.FormatBool(r)+"  ")
		}
		fmt.Println()
    }

    if err := scanner.Err(); err != nil {
        panic(err)
    }
}

func checkalgo(){
	f, err := excelize.OpenFile("./data/unslashed_double_votes.xlsx")
	if err!=nil {
		fmt.Println(err)
	}
	all_validators := getValidatorMap()
	both_true := 0
	both_false := 0
	true_false := 0
	count := 0

	// 405
	for i := 2; i < 406; i++ {
		idx := strconv.Itoa(i)
		validatorIdx, _ := f.GetCellValue("unslashed_double_votes", "B"+idx)
		validator, _ := strconv.Atoi(validatorIdx)
		blocksStr, _ := f.GetCellValue("unslashed_double_votes", "C"+idx)
		var blocks []int
		err := json.Unmarshal([]byte(blocksStr), &blocks)
		if err != nil {
			fmt.Println(err)
		}
		blocks = removeDuplicateInt(blocks)
		c, t, f:=0,0,0
		
		for _, blockSlot := range blocks {
			res := readBlockInfo(uint(blockSlot))
			for _, attestation := range (res.Data) {
				if !contains(attestation.Validators, validator) {
					// get data root
					// msg := attestation.Beaconblockroot
					// get pubkeys
					var pks []string
					for _, idx := range attestation.Validators {
						pks = append(pks, all_validators[idx][2:])
					}
					// get sig to verify
					sig := attestation.Signature
					check:=aggregateVerify(nil, pks, sig)
					fmt.Print(strconv.FormatBool(check)+"  ")
					if check{
						t++
					}else{
						f++
					}
					c++
					
				}
			}
		}
		if c==2 {
			count++
			if t==0 {
				both_false++
			}else if t==2{
				both_true++
			}else{
				true_false++
			}
		}
		fmt.Println()
	}
	fmt.Println(both_true, both_false, true_false, count)
}

func removeDuplicateInt(intSlice []int) []int {
    allKeys := make(map[int]bool)
    list := []int{}
    for _, item := range intSlice {
        if _, value := allKeys[item]; !value {
            allKeys[item] = true
            list = append(list, item)
        }
    }
    return list
}

func main() {
	bls.Init(bls.BLS12_381)
	bls.SetETHmode(bls.EthModeDraft07)
	
	allValidators = getValidatorMap2()
	writeValidatorDict(allValidators)


	// checkDoubleVoteWithLocalData()
	// checkSurroundVoteWithLocalData()
	// getValidatorMap2()
	
}